# 为什么使用服务

服务是为了一个构建某个或更大型产品所提供的功能性、有明确边界的系统。  

在一个面向服务的架构中，单个服务只包含所有业务逻辑的某个子集，这些独立的服务互相连接，为应用程序提供完整的业务逻辑。  

## 单体应用程序

独立的开发团队在相互重叠的部分同时工作，无法确切知道某一个时间点，谁在哪一块上工作，无法控制代码变更所导致的冲突和问题。代码质量及产生的系统质量和可用性也
会受到影响。此外，系统越来越复杂，单个开发团队变更代码也越来越困难，不得面对与其它团队的协作、互相冲突的改动以及内部纠缠不清等问题。  

## 基于服务的应用程序

每个服务都有一个清晰的负责人，并且每个团队都有一个清晰的、无重合的职责范围。面向服务的架构能够将一个应用程序拆分成多个不同的领域，每个领域由单独的团队来负责管理，职责
隔离对于构建大规模应用至关重要。  

构建大规模应用程序时，基于服务的应用提供以下几点好处：  

* 伸缩性决定：从更细粒度考虑伸缩性，进行更为有效的系统和组织优化。
* 团队分配和关注：将任务分配给不同的团队，让各自团队关注系统中不同的可伸缩和高可用需求。
* 复杂的本地化：将各个服务看作一个黑盒，服务的所有者需要了解该服务内部的复杂逻辑。
* 测试：测试比单体应用程序更容易测试。

## 服务所有权

服务约定包含以下两个部分：  

* 服务的能力  
	* 服务的用途
	* 如何调用服务以及每个调用的意义

* 服务的响应
	* API使用的频率
	* 什么时候可以使用API
	* API响应的速度
	* API是否存在依赖


## 规模收益

应用程序的不同部分在伸缩性上有着不同的需求，例如：生成首页的组件会比生成用户设置页面的组件会更频繁的使用到。通过独立管理每个服务的伸缩性需求，可以实现以下几点：

* 通过与相关功能负责团队的密切合作，提供更加准确的可伸缩性。
* 将系统资源留给真正需要伸缩性的组件。
* 将伸缩性的决定树交回团队，因为团队才是最了解服务需求的人（服务所有者）。

# 使用微服务

每个服务都是一个独立的组件，“独立”很重要，独立的服务必须满足以下几个条件：

* 维护自己的代码库：服务拥有自己的代码库，且区别于其它服务的代码库。
* 管理自己的数据：服务需要管理其自身数据的状态。服务之间唯一能访问到数据的方式就是通过它定义的API，其它服务不能够直接接触当前服务的数据或状态信息。
* 向其它服务提供能力：服务有一个定义良好的能力集合，并将这些能力提供给系统的中其它服务。
* 消费其它服务的能力：服务按标准的、约定的方式，使用其它服务提供的能力。
* 单一所有者：每个服务只能由一个开发团队负责和维护。虽然一个团队可以负责和维护多个服务。

## 如何定义服务

如何定义服务？没有唯一答案，整个行业在向着更小的微服务的趋势发展。Docker技术使得这些大量的微服务成为一种可能的系统拓扑。  

## 深入了解服务

以下原则可以用来确定服务边界，切忌是原则，不是规则。

* 特定的业务需求：是否有特定的业务需求会影响服务的边界，例如：会计、安全或监管。
* 清晰和独立的团队所有权：负责该功能的团队是否清晰和独立。
* 天然隔离的数据：其管理的数据是否天然地与系统的其它数据相对独立？将数据放到一个单独的数据存储器中是否会对系统造成过大压力。
* 共享的能力/数据：它是否提供了一些被其它服务使用的共享能力，是否这些共享能力需要共享数据？

### 原则1：特定的业务需求

某些情况下，某些特定的业务需求会决定一个服务的边界，这些关键的业务逻辑放在独立的服务中，有以下几点原因：   

* 法律/监管需求：因法律或监管要求需要保存特定的业务数据，将这些拆分成独立的服务，更容易处理这些数据。
* 安全：因安全考虑，需要额外的防火墙来保护这些服务器。
* 检验：对某些服务进行更加严格的产品测试，保证它们的安全性。
* 限制性访问：限制对这些服务器的访问，这样只有必备人员才能访问高度敏感的数据，例如支付信息等。

### 原则2：清晰和独立的团队所有权

应用程序复杂，需要越来越多的开发人员进行开发，随着引发的团队协作越来越难。服务能够将更小的、清晰的、独立的模块所有权赋予不同的团队。减少团队之间依赖，各自团队
更容易去运行系统和创新。  

### 出于安全等因素隔离团队

因安全问题，访问某个服务代码和数据的人员数量和范围，限制对含有敏感数据服务的访问、可以降低数据暴露所导致的问题。将敏感数据分成多个服务，可有效降低多个服务同时泄露
数据的风险。

### 原则3：天然隔离的数据

服务的一要求是：其托管状态和数据需要与其它数据相隔离。确定数据划分界线是确定服务划分界线的关键环节。服务负责自己的数据，并且通过服务接口来提供数据访问。

### 原则4：共享的能力/数据

服务负责提供一系列的能力和数据，这些能力和数据可能需要在很多其它服务之间共享。例如：用户身份服务。通过一个中心服务来提供和管理这类信息，在实际开发中非常实用。

## 多种原因

上述原则描述决定服务边界的基本标准，但还需综合考虑多种原因才能决定。示例：一个用户的个人资料有搜索选项，这个搜索项更适合存储在搜索服务中，而不是用户身份服务。

## 过犹不及

通常会将应用程序过度拆分成太多服务，但不能被滥用。服务拆分成过细粒度会带来一些问题，包括整体的系统性能影响。但是从最基本的角度来说，拆分成多个服务时，会做以下几件事情：

* 降低单个服务的复杂性
* 增加系统整体的复杂性

一个系统存在过多服务时，会带来以下几个问题：

* 影响大局观
* 更大故障几率
* 难以修改服务
* 更多依赖

## 适当平衡

决定服务的数量和每个服务的体积，是一个复杂问题，需要在创建更多服务所带来的好处，以及创建整体更复杂的系统带来的坏处之间，仔细进行平衡。


# 处理服务故障

## 级联式的服务故障

服务A依赖服务B、C和D，如果所依赖的服务故障，我们的服务也会出现故障，即级联式的服务故障（雪崩），在构建大型基于微服务的系统时，如何避免级联式的服务故障？

## 响应服务故障

某个依赖的服务出现故障时，作为开发人员，对依赖服务故障的响应必须是：

* 可预测的
* 可理解的
* 对当前情形是合理的

### 可预测的响应

可预测的响应实际意味着它是一个计划中的响应。当所依赖的服务异常时，不要有“好吧，我也做不了任何事情，只好任由服务出现故障”主动发现当前情况下，一个合理的响应是什么？需要检测当前的情况是否满足条件，并返回预期的响应。

### 可理解的响应

可理解，意味着和上游服务之间对响应的格式和结构表示同意，与所依赖的服务形成一个约定。即使所依赖的服务出现异常，响应也必须在控制的约定边界之内。不应该仅仅因为依赖服务违反了定义的API约定，就违反你自己的API约定。

### 合理响应

响应应该说明当前服务实际发生了什么。示例说明：

A服务调用B服务获取过期账户确认服务。合理的响应：B服务必须在所有情况下生成一个合理的响应。A合理的行为：如果该服务获取到一个不合理的响应，应该拒绝执行任务不合理或期望之外的行为。

## 如何确定故障

确定一个依赖服务是否出现故障，取决于故障模式，以下需要了解的故障模式：

* 乱码响应
* 表示致命错误发生的响应
* 结果可以理解但是所的结果不匹配：返回结果与预期结果不匹配
* 结果超出预期范围
* 没有接收到响应
* 接收响应很慢

## 适当的行为

错误发生时应该做哪些？取决天错误的类型，以下是针对不同的错误类型可以采取的方案。

### 优雅的降级

优雅降级指的在当前服务缺少某个故障服务的结果时，可以通过降低工作量来尽可能的完成工作。

### 优雅的补偿

优雅的补偿是指即使无法完全满足用户的需要时，但是可以按照为用户提供价值的方向去改进。例如：指定商品的详情页服务失败了，可以向用户展示一些当前流行产品的链接页面。

### 尽早失败

你的服务无法收到故障服务的响应，这种情况下，确定无法挽救请求，那么应当尽快让请求失败，不要再执行请求中的其它操作或任务。尽早失败的原因如下：

* 资源节约
* 响应性
* 错误复杂性：继续处理注定失败，很可能会造成更难诊断的问题。例如：账户服务存在性能问题，该服务越来越慢，直到它不可用，经研究发现，一个获取1万个账户的请求导致的（含帐户详细信息）。
该请求本身是无效，已超出请求的合理范围，但账户服务很负责的尝试处理该请求。不断请求不断处理，从而引发故障。





