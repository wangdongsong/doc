## 01 - Java虚拟机内存模型

> * 程序计数器
> * 虚拟机栈
> * 本地方法栈
> * Java堆
> * 方法区

可以分为线程共享和私有两大类：

线程共享：堆内存区、方法区、运行时常量池
线程私有：程序计数器、虚拟机栈

### 程序计数器

它是一块很小的内存空间，运行速度快，可以看成当前线程执行的字节码的行号指示器。在虚拟机中，字节码解释器的工作就是通过改变程序计数器来选择下一条需要执行的字节码指令、分支、循环、异常处理、跳转、线程恢复等。在多线程环境下，为了让线程切换
后恢复到正确的执行位置，每个线程都要有独立的程序计数器，各线程之间相互不影响、独立存储，因此程序计数器是线程私有的。

程序计数器类似于物理的寄存器的一种抽象模拟，因为是线程私有，所以生命周期和线程的生命同期一致。

根据JVM定义，程序计数器是唯一一个没有规定任何outOfMemoryError情况的区域。

### 虚拟机栈

虚拟机栈可以被快速访问，与程序计数器相同，线程私有，同Java线程在同一时间创建，保存方法的局部变量、部分结果，并参与方法的调用和返回。

Java虚拟机规范允许Java栈大小是动态或固定不变，规范定义了两种异常与栈空间有关，即StackoverFlowError和OutOfMemoryError。

**OutOfMemoryError**：如果栈可以动态扩展，而在扩展过程中没有足够的内存空间来支持栈的扩展，则程序运行过程中抛出OutOfMemoryError异常。
**StackoverFlowError**：线程计算过程中，请求的栈深度大于最大可用深度，则程序运行过程中招聘StackoverFlowError异常。

可以通过-XSS设置虚拟机栈的大小，栈的大小直接决定函数调用的最大可达深度。

#### 虚拟机栈内部结构

虚拟机栈在运行时使用一种叫栈帧的数据结构保存上下文数据，栈帧保存方法的局部变量表、操作数栈、动态连接方法和返回地址等信息。

> * 局部变量表（Local Variables）

是一个从0开始的数字数组，byte、short、char在存储前被转换为int，boolean也被转换为int，long和double则占据两个字长。通过数组下标访问。

> * 操作数栈

被组织为一个数字数组，不同于局部变量区，它不是通过数组下标访问，通过栈的Push和Pop操作。

> * 帧数据区

- 解析常量池里面的数据
- 方法执行完后处理方法返回，恢复调用方现场。
- 方法执行过程中招聘异常时的异常处理，存储在一个异常表。当出现异常时虚拟机查找相应在的异常表看是否有对应的catch语句，如果没有就抛出异常终止该方法调用。


### 本地方法栈

本地方法栈与Java虚拟机栈类似，Java虚拟机栈用于管理Java函数调用，本地方法栈用于本地方法调用，在Hotspot虚拟机中，不区分本地方法栈和虚拟机栈，会抛出StackOverFlowError和OutOfMemoryError。

### Java堆

堆在JVM规范中是一种通用性的内存池，用于存放所有的Java对象。堆是一种运行时数据区，在大多数虚拟机里，Java中的对象和数据都存放在堆中。堆相对于栈来讲具有较大的灵活性，不需知道分配多少存储等。

* 栈上分配
* 逃逸分析
* 内联分析

JDK7开始支持对象的栈分配和逃逸分析，该机制除了能将堆分配变成栈分配对象之外，还有以下两个优化应用：

* 同步消除：线程同步代价高，降低并发性和性能。逃逸分析可以判断出某个对象是否始终只被一个线程访问。如果只被一个线程访问，那么同步操作转为化为没有同步的保护操作。
* 矢量替换：逃逸分析如果发现对象的内存存储结构不需要连续进行的话，可以将对象的部分甚至全部保存在CPU寄存器内，提高访问速度。

### 方法区

保存信息的是类的元数据，与堆空间类似，被JVM中所有的线程共享的区域。主要包含以下信息：

* 类的类型信息：类的完整名称、父类的完整名称、类型修饰符和类的直接接口类表。
* 常量池：类方法、域信息所引用的常量信息。
* 域信息：域名称、域类型、域修饰符。
* 方法信息：方法名称、返回类型、参数列表、修饰符、方法字节码、操作数栈、方法栈桢、局部变量区大小、异常表。

![Java内存模型](Java-Memory-Model.png)

## 垃圾收集算法

### 引用计数法（垃圾收集算法）

### 根搜索算法（垃圾收集算法）

### 垃圾回收算法对比

|——| Mark-Seep | Mark-Compact | Copying|
|---|----------|--------------|--------|
|速度|中等|最慢|最快|
|空间开销|少（但会有碎片）|少（不堆积碎片）|通常需要存活对象的2倍大小（不堆积碎片）|
|移动对象|否|会|是|

### 标记-清除算法（垃圾回收算法）

用于年轻代，产生垃圾碎片

### 复制算法（垃圾回收算法）

用于年轻代，复制算法提高效率的代码是内存缩小一半

### 标记压缩算法（垃圾回收算法）

用于老年代

### 增量算法

### 分代收集算法

## Gargbage Collection

### 综述

根据以下6点评估GC性能：

* 吞吐量：程序运行时间（程序运行时间+内存回收时间）。
* 垃圾收集开销：吞吐量的补数，垃圾收集器所占时间和总时间的比例。
* 暂停时间：执行垃圾收集时间，程序的工作线程被暂停的时间。
* 收集频繁：相对于应用程序的执行，收集操作发生的频率。
* 堆空间：Java堆区所占的内存大小。
* 快速：一个对象从诞生到被回收所经历的时间。

### 垃圾收集器分类 

按线程数分：串行垃圾收集和并行垃圾收集

* 串行垃圾收集：同一时间段内只允许一个事件发生。多个CPU时，只能有一个CPU用于执行垃圾回收操作，并且回收过程中，程序线程被暂停，直到回收结束才恢复。其特点是<strong>单线程、独占式</strong>

* 并行垃圾收集：与串行垃圾收集基本类似，只是简单的将单线程修改为多线程。其它的回收策略、算法及参数和串行回收器一样。也是独占式，应用程序被暂停，但由于多线程，所以性能好于吕行。

按工作模式分：并发式垃圾回收器和独占式垃圾回收器

* 并发式垃圾回收器：与应用程序交替工作，尽可能减少应用程序的停顿时间。
* 独占式垃圾回收器：一旦运行，应用程序暂停，直到垃圾回收过程结束。

按碎片处理方式分：压缩式垃圾回收器和非压缩式垃圾回收器。
按工作内存方式分：年轻代垃圾回收器和老年代垃圾回收器。

### Serial收集器

年轻代，复制算法、串行回收和“Stop-The-World”
老年代，标记-压缩算法、串行回收，独占式垃圾回收器

**-XX:UseSerialGC:** 年轻代、老年代都使用串行回收器。
**-XX:UseParNewGC:** 指定年轻代使用并行收集器，老年代使用串行收集器。

### ParNew收集器

ParNew收集器是Serial收集器的多线程版本，采取复制算法、Stop-the-World机制。

ParNew收集器的优势在于多CPU、多核心环境中，并且在某些注重低延迟的应用场景下，ParNew收集器和CMS收集器的组合模式，在Server模式下的内存回收效果很好。

**-XX:+UseParNewGC:** 指定使用ParNew收集器执行内存回收任务，年轻代使用并行收集器，老年代使用串行收集器。

### Parallel收集器

Parallel收集拥有ParNew收集并行回收外，可以控制程序的吞吐量大小，同样采用复制算法（年轻代）、并行回收、Stop-the-World机制。也被称为吞吐量优先垃圾收集器。

**-XX:GCTimeRatio：** 设置执行内存回收时间所占JVM运行总时间的比例，也就是控制GC频率，公式为1/(1+N)，默认值为99，即将1%的时间用于执行垃圾回收。
**-XX:MaxGCPauseMills：**设置执行内存回收时“Stop-the-World”机制的暂停时间阀值，设定后，JVM尽可能在此时间范围内完成内存回收。
**-XX:ParallelGCThreads：**设置垃圾回收时线程数量。

**注意：** 吞吐量与低延迟本身矛盾，吞吐量优先，则降低内存回收的执行频率，但会导致GC需要更长的暂停时间执行内存回收。相反，低延迟优先，降低每次执行内存回收的暂停时间，只能频繁的执行内存回收，但又引起年轻代内存的缩减和导致程序吞吐量下降。

**-XX:UseAdaptiveSizePolicy:** 设置GC自动分代大小调节策略。

Parallel收集器也提供老年代Parallel Old收集器，老年代采用标记-压缩算法，但同样基于并行回收和Stop-the-World。

**-XX:+UseParallelGC:** 年轻代使用并行回收收集器，老年代使用串行收集器。
**-XX:+UseParallelOldGC:** 年轻代和老年代都是使用并行回收收集器。


