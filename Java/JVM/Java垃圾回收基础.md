# Java垃圾回收基础

标签（空格分隔）： GC 垃圾回收 JVM

---

垃圾回收器常用的算法  

###引用计数法（Reference Counting）  

&#160; &#160; &#160;&#160;引用计算法是唯一没有使用根集的垃圾回收的算法，该算法使用引用计数器来区分存活对象和不再使用的对象。为每一个对象配置一个整形的计数器即可实现。当每一次创建一个对象会赋值给一个变量时，计数器加1，当变量超出作用域时减1，一旦计数器为0，对象就满足了垃圾收集的条件。  

&#160; &#160; &#160;&#160;基于引用计数器的垃圾收集器运行较快，不会长时间中断程序执行。但引用计数器增加了程序执行开销。因为每次对象赋值给新变量，计数器加1，而每次有对象出了作用域后，计数器减1。  

&#160; &#160; &#160;&#160;例如：对一个对象A，只要任何对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1，只要对象A的引用计数器的值为0时，则对象A就可能不再使用，即可回收。    

&#160; &#160; &#160;&#160;但是引用计数器无法解决循环引用的问题。有对象A和B，对象A中含有对象B的引用，同时对象B也有对象A的引用。此是对象A和B的引用计数器都不为0。但是在系统中已经不存任何其它对象引用了A和B，也就是说，对象A和B也应该被回收的垃圾对象，但是由于垃圾对象间相互引用，从而使用垃圾 收集器无法识别，引起内存泄漏。   

###标记-清除算法（Mark-Sweep）  

####基本概念  

&#160; &#160; &#160;&#160;基本概念mutator和collector，是垃圾收集算中出现的名词，collector指的就是垃圾收集器，而mutator是指除了垃圾收集器之外的部分，比如说我们应用程序本身。mutator的职责一般是NEW（分配内存），READ（从内存中读取内容），WRITE（将内容写入内存），而collector则就是回收不再使用的内存来供mutator进行NEW操作的使用。   

&#160; &#160; &#160;&#160;第二个基本概念mutator roots（mutator根对象），mutator根对象一般指的是分配在堆内存之外，可以直接被mutator直接访问到的对象，一般是指静态/全局变量及ThreadLocal变量（在Java中，存储在java.lang.ThreadLocal中的变量和分配在栈上的变量，方法内部的临时变量等属于此类）  

&#160; &#160; &#160;&#160;第三个基本概念是关于可达对象的定义，从mutator根对象开始进行遍历，可以被访问到的对象称为可达对象。这些对象也是mutator（你的应用程序）正在使用的对象。  

####算法原理  

&#160; &#160; &#160;&#160;标记-清除算法分为两个阶段：标记（mark）和清除（sweep）。  

&#160; &#160; &#160;&#160;在标记阶段，collector从mutator根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标记，一般是在对象的header中，将其记录为可达对象。  

&#160; &#160; &#160;&#160;在清除阶段，collector对堆内存（heap memory）从头到尾进行线性遍历，如果发现某个对象没有标记为可达对象，通过读取对象的header信息，则就将其回收。  

&#160; &#160; &#160;&#160;Collector在进行标记和清除阶段时会将整个应用程序暂停（mutator），等待标记清除结束后才会恢复应用程序的运行，这也是Stop-The-World这个单词的来历。  

####缺点
&#160; &#160; &#160;&#160;标记-清除算法比较大的缺点就是垃圾收集后有可能造成大量的内存碎片，像上面的图片所示，垃圾收集后中存在三个内存碎片，假设一个方格代表一个单位的内存，如果有一个对象需要占用3个内存单位的话，那么就会导致Mutator一直处于暂停状态，而Collector一直在尝试进行垃圾收集，直到Out of Memory。  

&#160; &#160; &#160;&#160;通过俗讲：在回收后，内存空间是不连接的，在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连接的空间。  

###复制算法（Copying）
&#160; &#160; &#160;&#160;将现有的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的存活对象复制到未被使用的内存块中，之后把这块内存整个清理掉。

&#160; &#160; &#160;&#160;系统中的垃圾对象很多，复制算法要复制的存活对象数量并不会太大。因此在真正垃圾回收的时刻，复制算法的效率是很高的。由于对象在垃圾回收过程中统一被复制到新的内存空间中，因此可确保回收后的内容空间是没有碎片的。

**缺点**：内存折半。

&#160; &#160; &#160;&#160;Java的新生代串行垃圾回收器中使用了复制算法。新生代分为eden空间、from空间、to空间3个部分，其中from和to空间可以视为用于复制的两块大小相同、地位相等，且可以进行角色互换的空间块。from和to空间也称为survivor空间，即幸存者空间，用于存放未被回收的对象。  

&#160; &#160; &#160;&#160;在垃圾回收时，eden空间中的存活对象会被复制到未使用的survivor空间中（假设是to），正在使用的survivor空间（假设是from)中的年轻对象也会被复制到to空间中（大对象或者老年对象会直接进入老年代，如果to空间已满，则对象也会直接进入老年代）。此时，eden空间和from空间中剩余对象就是垃圾对象，可以直接清空，to空间则存放此次回收后的存活对象。这种改进的复制算法即保证了空间的连续性，又避免了大量的内存空间浪费。  

###标记-压缩算法（Mark-Compact）

&#160; &#160; &#160;&#160;复制算法的高效性是建立在存活对象少、垃圾对象多的前提下。这种情况在年轻代经常发生，但是在老年代更常见的情况是大部分对象是存活对象，如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。

&#160; &#160; &#160;&#160;标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。也首先需要从根节点开始对所有可达对象做一次标记，但之后它并不简单地清理未标记的对象，而将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间，这种方法即避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。

###增量算法

&#160; &#160; &#160;&#160;在垃圾回收过程，应用软件将处于一种CPU消耗很高的状态，在这种状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体检或者系统的稳定性。

&#160; &#160; &#160;&#160;增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文件切换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。

###分代

&#160; &#160; &#160;&#160;根据垃圾回收对象的特性，不同阶段最优的方式是使用合适的算法用于本阶段的垃圾回收，分代算法即是基于这种思想，它将内存区间根据对象的特点分成几块，根据每块内存区域的特点，使用不同的回收算法，以提高垃圾回收的效率。以Hot Spot虚拟机为例，它将所有的新建对象都放入称为年轻代的内存区域，年轻代的特点是对象会很快回收，因此，在年轻代就选择效率较高的复制算法。当一个对象经过几次回收后依然存活，对象就会放入称为老年代的内存空间。在老年代中，几乎所有的对象都是经过几次垃圾回收后依然得以幸存的。因此，可以认为这些对象在一段时期内，甚至在应用程序的整个生命周期中，将是常驻内存的。如果依然使用复制算法回收老年代，将需要复制大量对象。再加上老年代回收价比低于新生代，因此这种做法也是不可取的。根据分代思想，可以对老年代的回收使用与新生代不同的标记-压缩算法，以提高垃圾回收效率。

从不同的角度分析垃圾收集器，可以将其分为不同的类型：

&#160; &#160; &#160;&#160;1、按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。串行垃圾回收器一次只使用一个线程进行垃圾回收；并行垃圾回收器一次将开启多个线程同时进行垃圾回收。在并行能力较强的CPU上，使用并行垃圾回收器可以缩短GC的停顿时间。

&#160; &#160; &#160;&#160;2、按工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间；独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有线程，直到垃圾回收过程完全结束。

&#160; &#160; &#160;&#160;3、按碎片处理方式可分为压缩式垃圾回收器和非压缩式垃圾回收器。压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片；非压缩式的垃圾回收器不进行这步操作。

&#160; &#160; &#160;&#160;4、按工作的内存区间，可分为新生代垃圾回收器和老年代垃圾回收器。

**可以使用以下指标评价一个垃圾处理器的好坏**
&#160; &#160; &#160;&#160;吞吐量：批在应用程序的生命周期内，应用程序所花费的时间和系统总运行时间的比值。系统总运行时间=应用程序耗时+GC耗时。如果系统运行100min，GC用时1min，那么系统的吞量就是（100-1）/100=99%。

&#160; &#160; &#160;&#160;垃圾回收器负载：和吞吐时相反，垃圾回收器负载指来记回收器消耗时与系统运行总时间的比值。

&#160; &#160; &#160;&#160;停顿时间：指垃圾回收器正在运行时，应用程序的暂停时间。对于独占回收器而言，停顿时间可能会比较长。使用并发的回收器时，由于垃圾回收器和应用程序交替运行，程序的停顿时间会变短，但是，由于其效率可能不如独占垃圾回收器，故系统的吞量可能较低。

&#160; &#160; &#160;&#160;垃圾回收频率：指垃圾回收器多长时间会运行一次。一般来说，对于固定的应用而言，垃圾回收器的频率应该是越低越好。通常增大堆空间可以有效降低垃圾回收发生的频率，但是可能会增加回收产生的停顿时间。

&#160; &#160; &#160;&#160;反应时间：指当一个对象被称为垃圾后多长时间内，它所占据的内存空间会被释放。

&#160; &#160; &#160;&#160;堆分配：不同的垃圾回收器对堆内存的分配方式可能是不同的。一个良好的垃圾收集器应该有一个合理的堆内存区间划分。






